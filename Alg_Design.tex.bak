\chapter{Algorithm Design and Implementation} \label{ch:alg_design}

\section{UKF Formulation}

We begin by defining the following vector quantities:
%
\begin{equation}
tk: p, q, v, \omega, a
\end{equation}
%
tk: define n and m


We then define the state vector $\mathbf{x} \in \mathbb{R}^{n}$:
%
\begin{equation}
\mathbf{x} \triangleq \left\lbrace
\mathbf{p},
\mathbf{q},
\mathbf{v},
\mathbf{\omega},
\mathbf{a},
\right\rbrace ^{T}.
\end{equation}
%
The covariance associated with each state $\mathbf{x}$ is a matrix $\mathbf{P} \in \mathbb{R}^{n \times n}$. A set of $2n + 1$ sigma points is then derived from $\mathbf{x}$ and $\mathbf{P}$:
%
\begin{align}
\mathbf{\chi}^{0} &= \mathbf{x} \nonumber\\
\mathbf{\chi}^{i} &= \mathbf{x} + \left( \sqrt{\left( n + \lambda \right) \mathbf{P} } \right)_{i}, \quad i = 1, \dots, n \\
\mathbf{\chi}^{i} &= \mathbf{x} - \left( \sqrt{\left( n + \lambda \right) \mathbf{P} } \right)_{i-n}, \quad i = n+1, \dots, 2n \nonumber
\end{align}
%
where $\lambda$ is defined in terms of the following constants:
%
\begin{equation}
tk: \alpha, \beta, \kappa, \lambda
\end{equation}

tk: TO BE CONT'D.

\section{Software Design Considerations}

Much of the impetus for creating the \texttt{kalman\_sense} package came from a desire to create a generic UKF framework for estimating the state of arbitrary systems using any number of relative and absolute sensors. To achieve this, the \texttt{kalman\_sense} package is organized in an object-oriented manner around an overarching abstract class called \texttt{UnscentedKf}. This abstract class contains a number of methods performing the different mathematical operations defined in Section~\ref{sec:ukf_formulation}. These methods have been written in a generic manner in order to enable easy extension of \texttt{UnscentedKf} by other subclasses containing concrete implementations of various systems. Currently, the package contains exactly one such subclass, known as \texttt{QuadUkf}. This subclass contains methods and data structures related directly to estimating the state of a quadcopter or other rotorcraft UAV.

This object-oriented architecture is meant to allow for a certain degree of system agnosticism. The abstract \texttt{UnscentedKf} class encapsulates the generic mathematics of the Unscented Kalman Filter without knowledge of particular system constraints. This class does little other than matrix mathematics and is designed to take as input the number of a system's states $n$ and its number of sensors $m$. With this knowledge, \texttt{UnscentedKf} is able to populate a set of mean and covariance weights and intelligently perform all of the requisite linear algebra for the UKF formulation. All other knowledge of particular states, sensors, vehicle geometry, and other particulars is hidden within subclasses such as \texttt{QuadUkf}.

\texttt{UnscentedKf} behaves in a manner similar to a Java interface in that it requires the extending class to supply functions codifying a process model and an observation model for the system under scrutiny. These two functions, along with $n$ and $m$, form the entirety of what \texttt{UnscentedKf} ``knows about the vehicle.'' All other details, including the fact that the class is being used in a ROS environment, are hidden from \texttt{UnscentedKf}. It is worth noting that \texttt{UnscentedKf}'s only dependency is on the Eigen\footnote{\url{www.eigen.tuxfamily.org}} C++ linear algebra library.

The subclass (\texttt{QuadUkf} for the remainder of this thesis) handles all of the ROS communications for the given system. Specifically, this class has callback functions for receiving sensor data and is responsible for publishing state and covariance estimates. The \texttt{kalman\_sense} \texttt{main} method handles setup and teardown of the necessary ROS publisher and subscriber nodes.

