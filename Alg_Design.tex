\chapter{Algorithm Design and Implementation} \label{ch:Alg_Design}

\section{UKF Formulation} \label{sec:ukf_formulation}

\subsection{Prediction Step}

We begin by defining the following quantities:
%
\begin{align} \label{eq:state_vars}
\mathbf{p} &= \left\lbrace x, y, z \right\rbrace ^{T} \\
\mathbf{q} &= \left\lbrace q_{x}, q_{y}, q_{z}, q_{w} \right\rbrace ^{T} \\
\mathbf{v} &= \left\lbrace \dot{x}, \dot{y}, \dot{z} \right\rbrace ^{T} \\
\bm{\Omega} &= \left\lbrace \omega_{x}, \omega_{y}, \omega_{z} \right\rbrace ^{T} \\
\mathbf{a} &= \left\lbrace \ddot{x}, \ddot{y}, \ddot{z} \right\rbrace ^{T}
\end{align}
%
The vectors $\mathbf{p}$, $\mathbf{v}$, and $\mathbf{a}$ represent the vehicle's position, velocity, and acceleration, respectively. The quaternion\footnote{From here on, all quaternion quantities are represented according to the convention $\mathbf{q} = \left\lbrace q_{x}, q_{y}, q_{z}, q_{w} \right\rbrace ^{T}$, where $q_{w}$ is the scalar component and is always placed in the last position. This convention was chosen to maintain consistency with the Eigen library's internal representation of quaternions.} $\mathbf{q}$ represents the vehicle's orientation, and the vector $\bm{\Omega}$ represents the vehicle's angular rates. We now define the state vector $\mathbf{x}$ as
%
\begin{equation}
\mathbf{x} = 
\Big\{
    \mathbf{p}^{T},
    \mathbf{q}^{T},
    \mathbf{v}^{T},
    \bm{\Omega}^{T},
    \mathbf{a}^{T}
\Big\} ^{T}
\end{equation}
%
and let $n = 16$ represent the number of state variables.

We now define the following constants:
%
\begin{align}
\alpha &= 0.75 \nonumber \\
\kappa &= 0 \nonumber \\
\beta &= 2 \\
\lambda &= \alpha^{2} \left( n + \kappa \right) - n \nonumber \\
&= -7 \nonumber
\end{align}
%
The constants $\alpha$ and $\kappa$ control the spread of sigma points chosen within the filter. The value of $\beta$ governs what distribution is assumed for the states $\mathbf{x}$. According to Wan et al.\ in \cite{Wan2000}, setting $\beta = 2$ is optimal for a Gaussian state distribution, which we assume throughout. With these constants defined, we can now describe the selection of sigma points.

Let $\mathbf{P} \in \mathbb{R}^{n \times n}$ be the covariance matrix associated with the state $\mathbf{x}$. A set of $2n + 1$ sigma points is then derived from $\mathbf{x}$ and $\mathbf{P}$ as
%
\begin{align}
\bm{\chi}^{0}_{k-1 | k-1} &= \mathbf{x}_{k-1 | k-1} \nonumber\\
\bm{\chi}^{i}_{k-1 | k-1} &= \mathbf{x}_{k-1 | k-1} + \left( \sqrt{\left( n + \lambda \right) \mathbf{P}_{k-1 | k-1}} \right)_{i}, &&i = 1, \dots, n \\
\bm{\chi}^{i}_{k-1 | k-1} &= \mathbf{x}_{k-1 | k-1} - \left( \sqrt{\left( n + \lambda \right) \mathbf{P}_{k-1 | k-1}} \right)_{i-n}, &&i = n+1, \dots, 2n, \nonumber
\end{align}
%
where $\bm{\chi}^{i}$ is the $i$-th sigma point and $\left( \sqrt{\left( n + \lambda \right) \mathbf{P}_{k-1 | k-1}} \right)_{i}$ is the $i$-th column of the matrix $\sqrt{\left( n + \lambda \right) \mathbf{P}_{k-1 | k-1}}$. The matrix square root $\mathbf{A}$ of a matrix $\mathbf{B}$ is defined here as
%
\begin{equation}
\mathbf{A} \mathbf{A}^{T} = \mathbf{B}
\end{equation}
%
and is computed via Cholesky decomposition\todo{citation? example in appendix?}.

To predict the next state, these sigma points are propagated through the nonlinear process function $f$ (defined in Section~\ref{Process_Model}):
%
\begin{equation}
\bm{\chi}^{i}_{k | k-1} = f \left( \bm{\chi}^{i}_{k-1 | k-1} \right), \quad i = 0, \dots, 2n.
\end{equation}
%
These new sigma points are then used to predict the next state and covariance:
%
\begin{align}
\hat{\mathbf{x}}_{k | k-1} &= \sum^{2n}_{i=0} W^{i}_{s} \bm{\chi}^{i}_{k | k-1} \\
\mathbf{P}_{k | k-1} &= \left( \sum^{2n}_{i=0} W^{i}_{c} \left( \bm{\chi}^{i}_{k | k-1} - \hat{\mathbf{x}}_{k | k-1} \right) \left( \bm{\chi}^{i}_{k | k-1} - \hat{\mathbf{x}}_{k | k-1} \right)^{T} \right) + \mathbf{Q}_{k},
\end{align}
%
where the state weights $W_{s}$ and covariance weights $W_{c}$ are defined as
%
\begin{align}
W^{0}_{s} &= \dfrac{\lambda}{n + \lambda} \nonumber \\
W^{0}_{c} &= \dfrac{\lambda}{n + \lambda} + \left( 1 - \alpha^{2} + \beta \right) \\
W^{i}_{s} &= W^{i}_{c} = \dfrac{1}{2 \left(n + \lambda \right)}, \quad i = 1, \dots, 2n \nonumber
\end{align}
%
and the process noise covariance matrix $\mathbf{Q}_{k}$ will be defined in Section~\ref{sec:Q_Matrix}.


\subsection{Correction Step}

Given the belief defined by $\mathbf{x}_{k | k-1}$ and $\mathbf{P}_{k | k-1}$, we compute $2n + 1$ sigma points again as
%
\begin{align}
\bm{\chi}^{0}_{k | k-1} &= \mathbf{x}_{k | k-1} & \nonumber\\
\bm{\chi}^{i}_{k | k-1} &= \mathbf{x}_{k | k-1} + \left( \sqrt{\left( n + \lambda \right) \mathbf{P}_{k | k-1}} \right)_{i}, &&i = 1, \dots, n \\
\bm{\chi}^{i}_{k | k-1} &= \mathbf{x}_{k | k-1} - \left( \sqrt{\left( n + \lambda \right) \mathbf{P}_{k | k-1}} \right)_{i-n}, &&i = n+1, \dots, 2n. \nonumber
\end{align}
%
Next, the sigma points are projected through the observation function $h$ (defined in Section~\ref{Observation_Model}):
%
\begin{equation}
\bm{\gamma}^{i}_{k} = h \left( \bm{\chi}^{i}_{k | k-1} \right), \quad i = 0, \dots, 2n.
\end{equation}

Let $m = 7$ represent the number of measurements taken from each PTAM message. Each of these messages is read in as an $m$-dimensional measurement vector $\mathbf{z}_{k}$ of the form
%
\begin{equation}
\mathbf{z}_{k} = \left\lbrace x, y, z, q_{x}, q_{y}, q_{z}, q_{w} \right\rbrace ^{T} _{meas.} .
\end{equation}
%
The predicted measurement vector $\hat{\mathbf{z}}_{k}$ and measurement noise covariance $\mathbf{P}_{zz}$ are then computed as
%
\begin{align}
\hat{\mathbf{z}}_{k} &= \sum^{2n}_{i=0} W^{i}_{s} \bm{\gamma}^{i}_{k} \\
\mathbf{P}_{zz} &= \left( \sum^{2n}_{i=0} W^{i}_{c} \left( \bm{\gamma}^{i}_{k} - \hat{\mathbf{z}}_{k} \right) \left( \bm{\gamma}^{i}_{k} - \hat{\mathbf{z}}_{k} \right)^{T} \right) + \mathbf{R},
\end{align}
%
where $\mathbf{R}$ is the measurement noise covariance matrix (defined in Section~\ref{sec:R_Matrix}). The state-measurement cross-covariance $\mathbf{P}_{xz}$ is then defined as
%
\begin{equation}
\mathbf{P}_{xz} = \sum^{2n}_{i=0} W^{i}_{c} \left( \bm{\chi}^{i}_{k | k-1} - \hat{\mathbf{x}}_{k | k-1} \right) \left( \bm{\gamma}^{i}_{k} - \hat{\mathbf{z}}_{k} \right)^{T} .
\end{equation}
%
Next, we compute the Kalman gain $\mathbf{K}_{k}$ per the definition
%
\begin{equation}
\mathbf{K}_{k} = \mathbf{P}_{xz} \mathbf{P}^{\,-1}_{zz}.
\end{equation}
%
The corrected state $\hat{\mathbf{x}}_{k | k}$ is then the sum of the predicted state and the innovation, weighted by $\mathbf{K}_{k}$:
%
\begin{equation}
\hat{\mathbf{x}}_{k | k} = \hat{\mathbf{x}}_{k | k-1} + \mathbf{K}_{k} \left( \hat{\mathbf{z}}_{k} - \mathbf{z}_{k} \right) .
\end{equation}
%
The corrected covariance $\mathbf{P}_{k | k}$ is the difference between the predicted covariance $\mathbf{P}_{k | k-1}$ and the predicted measurement covariance, weighted by the Kalman gain:
%
\begin{equation}
\mathbf{P}_{k | k} = \mathbf{P}_{k | k-1} - \mathbf{K}_{k} \mathbf{P}_{zz} \mathbf{K}_{k}^{T} .
\end{equation}

\subsection{Process Model} \label{Process_Model}

To propagate the vehicle's state forward in time, we perform a number of integration operations on the linear accelerations and angular rates measured by the IMU. To determine the orientation of the vehicle at some time $k$, we integrate the measured angular rate vector $\bm{\Omega}_{meas.}$ per the relationship
%
\begin{equation} \label{eq:proc_quat}
\mathbf{q}_{k} = \mathbf{q}_{k-1} + \frac{1}{2} \mathbf{\Theta} \left( \bm{\Omega}_{k} \right) \mathbf{q}_{k-1} \Delta t ,
\end{equation}
%
where $\mathbf{\Theta} \left( \bm{\Omega}_{k} \right) \in \mathbb{R}^{4 \times 4}$ is the angular rate integration matrix defined by
%
\begin{equation}
\mathbf{\Theta} \left( \bm{\Omega}_{k} \right) =
\begin{bmatrix}
0 & \omega_{z} & -\omega_{y} & \omega_{x} \\
-\omega_{z} & 0 & \omega_{x} & \omega_{y} \\
\omega_{y} & -\omega_{x} & 0 & \omega_{z} \\
-\omega_{x} & -\omega_{y} & -\omega_{z} & 0
\end{bmatrix}
\end{equation}
%
and the vehicle's current angular velocity vector is measured directly by the gyroscope:
%
\begin{equation} \label{eq:proc_ang_vel}
\bm{\Omega}_{k} = \bm{\Omega}_{meas.} .
\end{equation}

To calculate the vehicle's current acceleration, we first subtract gravity from the measured acceleration vector $\mathbf{a}_{meas.}$ and then rotate the difference into the inertial frame: \todo{Have Sam look over this. Are subscripts right?}
%
\begin{equation} \label{eq:proc_acc}
\mathbf{a}_{k} = R^{g}_{b} \left[ \mathbf{q}_{k-1} \right] \left( \mathbf{a}_{meas.} - \mathbf{g} \right) .
\end{equation}
%
Here $R^{g}_{b} \left[ \mathbf{q}_{k-1} \right]$ is the rotation matrix representation of the previous orientation quaternion $\mathbf{q}_{k-1}$ and $\mathbf{g}$ is the vector representation of gravity in the global frame. \todo{What is R(q)?}

With the vehicle's current acceleration known, we can compute the current velocity of the vehicle by integrating the vehicle's average acceleration between the current and previous time steps:
%
\begin{equation} \label{eq:proc_vel}
\mathbf{v}_{k} = \mathbf{v}_{k-1} + \frac{1}{2} \left( \mathbf{a}_{k} + \mathbf{a}_{k-1} \right) \Delta t .
\end{equation}
%
Similarly, we compute the vehicle's current position using the vehicle's average velocity:
%
\begin{equation} \label{eq:proc_pos}
\mathbf{p}_{k} = \mathbf{p}_{k-1} + \frac{1}{2} \left( \mathbf{v}_{k} + \mathbf{v}_{k-1} \right) \Delta t .
\end{equation}

Together, equations~\ref{eq:proc_quat}, \ref{eq:proc_ang_vel}, \ref{eq:proc_acc}, \ref{eq:proc_vel}, and \ref{eq:proc_pos} constitute the nonlinear process function $f$:\todo{fill out f}
%
\begin{equation}
f\left( \mathbf{x}_{k} \right) = 
\begin{Bmatrix}
    tk
\end{Bmatrix}
\end{equation}

\subsection{Observation Model} \label{Observation_Model}

\subsubsection{Quaternion Continuity Correction}

Due to a defect in the ROS PTAM implementation, quaternion estimates switch sign without warning after rotations of approximately 270 degrees. To prevent loss of continuity in quaternion estimates, we keep the previous quaternion estimate $\mathbf{q}_{k-1}$ in memory and employ the following algorithm to correct the incoming quaternion estimate if a sign-flip has occurred:\todo{fill this out more?}

\begin{algorithm}
  \caption{Check for continuity between quaternion estimates}
    \label{alg:checkQuatContinuity}
  \begin{algorithmic}[1]
    \Statex
    \Function{CheckQuaternionContinuity}{$\mathbf{q}_{k-1},\ \mathbf{q}_{k}$}
     \State $\text{sum} = \left| \left| \mathbf{q}_{k-1} + \mathbf{q}_{k} \right| \right|$
     \State $\text{diff} = \left| \left| \mathbf{q}_{k-1} - \mathbf{q}_{k} \right| \right|$
        \If{$\text{diff} \leq \text{sum}}$
        \State $\mathbf{q}_{k} = - \mathbf{q}_{k}$
        \EndIf
      \State \Return{$\mathbf{q}_{k}$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsubsection{Pseudovelocity Correction}

Of the various states being measured, only the acceleration vector $\mathbf{a}$ and angular rate vector $\bm{\Omega}$ are measured directly by the IMU:
%
\begin{equation}
\mathbf{x} = 
\Big\{   
    \mathbf{p}^{T},
    \mathbf{q}^{T},
    \mathbf{v}^{T},
    \underbrace{
    \bm{\Omega}^{T},
    \mathbf{a}^{T}}_{IMU}
\Big\} ^{T}.
\end{equation}
%
The vehicle's position $\mathbf{p}$ and orientation $\mathbf{q}$ are measured directly by PTAM:
%
\begin{equation}
\mathbf{x} = 
\Big\{
\underbrace{
    \mathbf{p}^{T},
    \mathbf{q}^{T}}_{PTAM},
    \mathbf{v}^{T},
    \bm{\Omega}^{T},
    \mathbf{a}^{T}
\Big\} ^{T}.
\end{equation}
%
The vehicle's velocity $\mathbf{v}$, however, is not measured by either the IMU or PTAM. There is no sensor in place by which $\mathbf{v}$ can be directly measured. Therefore, velocity must be determined through a derived measurement.

Because velocity is predicted by integrating the vehicle's acceleration (Section~\ref{Process_Model}), noise in the accelerometer can cause unbounded drift in the velocity. The resulting erroneous velocity then propagates through each successive prediction step, causing drift in the estimated position \textit{regardless of any corrective position measurements from PTAM}. In this situation, the filter produces position estimates which drift at a constantly increasing rate between PTAM messages. The Kalman Filter corrects the position each time that a PTAM message arrives, only to drift again a fraction of a second later when the next IMU message arrives. This kind of intermittent drift produces sharp ``bounces'' in the vehicle's estimated trajectory and undermines any variety of desired numerical stability.

To prevent this potentially catastrophic drift, velocity is estimated by numerical differentiation of the vehicle's position during each correction step. When a PTAM message is received, the position reading from the last PTAM message is subtracted from the current position reading. This change in position is then divided by the time step between the two PTAM messages, $\Delta t_{P}$:
%
\begin{equation}
\mathbf{v}_{k} = \frac{\mathbf{p}_{k,\ meas.} - \mathbf{p}_{k-1,\ meas.}}{\Delta t_{P}} .
\end{equation}
%
This pseudovelocity correction prevents unbounded velocity drift, which in turns makes the filter's output numerically stable.

\subsection{Process Noise Covariance Matrix} \label{sec:Q_Matrix}
\todo{diagonality?}
The process noise covariance matrix $\mathbf{Q}_{k} \in \mathbb{R}^{n \times n}$ is symmetric, time-dependent, and positive definite. We assume that its nonzero coefficients are a function of multiple integrations between the linear accelerations and angular velocities measured by the vehicle's 3-axis accelerometer and 3-axis gyroscope.

We assume that all axes of the accelerometer and gyroscope exhibit white noise with known standard deviations $\sigma_{a}$ and $\sigma_{\omega}$, respectively\footnote{This claim of equal standard deviations between axes is supported by the IMU data sheet.}. We further assume that no cross-axis covariance exists between any two accelerometer axes or any two gyroscope axes.

For the sake of convenient estimation, we assume that the accelerometer and gyroscope variance terms grow linearly over each discrete time step $\Delta t$. Thus, in the case of the $x$-axis accelerometer and the $x$-axis gyroscope, the corresponding terms of $\mathbf{Q}_{k}$ would be
%
\begin{equation}
Q_{a_{x},a_{x}} = \sigma_{a} \Delta t
\end{equation}
%
and
%
\begin{equation}
Q_{\omega_{x},\omega_{x}} = \sigma_{\omega} \Delta t ,
\end{equation}
%
respectively. We can now estimate the other nonzero terms of $\mathbf{Q}_{k}$ according to their integral relationships with the acceleration and angular velocity measurements.

\todo{integral equations}

We assume no coupling between the angular quantities ($\mathbf{q}$ and $\bm{\Omega}$) and the linear quantities ($\mathbf{p}$, $\mathbf{v}$, and $\mathbf{a}$), making the process noise covariance matrix largely sparse. This assumption logically stems from the small angle assumption. Because the IMU runs at 250~Hz, we assume that the vehicle makes only small rotations between IMU measurements. 

\todo{full Q matrix}


\subsection{Measurement Noise Covariance Matrix} \label{sec:R_Matrix}
\todo{diagonality? Q-R ratio?}
The matrix $\mathbf{R} \in \mathbb{R}^{m \times m}$ models the covariance between measurements made by the pose sensor, PTAM. Like the process noise covariance matrix $\mathbf{Q}_{k}$, the measurement noise covariance matrix $\mathbf{R}$ is symmetric and positive definite. However, for the purposes of this experiment, $\mathbf{R}$ is assumed to be time-invariant due to nearly constant feature density in the experimental scene. Because the vehicle camera moves across the scene at an almost constant height (that is, at a nearly constant distance to the features it observes on the floor), the measurement noise covariance of the pose sensor is assumed to be approximately constant in time. The coefficients of $\mathbf{R}$ were estimated by numerically computing the covariances between raw measurements from PTAM and the ``ground truth'' supplied by a Vicon motion capture system\footnote{\url{https://www.vicon.com/}}.

The resulting $\mathbf{R}$ matrix is as follows:
%
\todo{R Matrix}

\section{Software Design Considerations}

Much of the impetus for creating the \texttt{kalman\_sense} ROS package came from a desire to create a generic UKF framework for estimating the state of an arbitrary system using any number of relative and absolute sensors. To achieve this, the \texttt{kalman\_sense} package is organized in an object-oriented manner around an overarching abstract class called \texttt{UnscentedKf}. This abstract class contains a number of methods performing the different mathematical operations defined in Section~\ref{sec:ukf_formulation}. These methods have been written in a generic manner to enable easy extension of \texttt{UnscentedKf} by subclasses containing concrete implementations of various systems. Currently, the package contains only one subclass, known as \texttt{QuadUkf}. This subclass contains methods and data structures related directly to estimating the state of a quadcopter or other rotorcraft UAV.

The \texttt{UnscentedKf} class encapsulates the generic mathematics of the UKF without knowledge of particular system constraints. This class does little other than matrix mathematics and is designed to take as input the number of a system's states $n$ and its number of sensors $m$. With this information, \texttt{UnscentedKf} is able to populate a set of mean and covariance weights and then intelligently perform all of the requisite linear algebra for the UKF formulation. All other knowledge of particular states, sensors, vehicle geometry, and other metrics is hidden within subclasses such as \texttt{QuadUkf}.

\texttt{UnscentedKf} behaves in a manner similar to a Java interface in that it requires the extending class to supply functions codifying a process model and an observation model for the system under scrutiny. These two functions, along with $n$ and $m$, form the entirety of what \texttt{UnscentedKf} ``knows'' about the vehicle. All other details, including the fact that the class is being used in a ROS environment, are hidden from \texttt{UnscentedKf}. It is worth noting that \texttt{UnscentedKf}'s only dependency is on the Eigen C++ linear algebra library\footnote{\url{www.eigen.tuxfamily.org}}.

The subclass (\texttt{QuadUkf} for the remainder of this thesis) handles all of the ROS communications for the given system. Specifically, this class has callback functions for receiving sensor data and is responsible for publishing state and covariance estimates.

